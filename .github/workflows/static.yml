# Simple workflow for deploying static content to GitHub Pages
name: Deploy static content to Pages

on:
  # Runs on pushes targeting the default branch
  push:
    branches: ["main"]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: read
  pages: write
  id-token: write

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  # Single deploy job since we're just deploying
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Generate meta.json
        run: |
          python3 -c "
          from pathlib import Path
          import json

          manuals_root = Path('manuals')
          web_root = Path('web')
          manuals = []
          tag_definitions = {}

          for folder in sorted(manuals_root.iterdir()):
              if not folder.is_dir():
                  continue
              json_path = folder / 'translations.json'
              if not json_path.exists():
                  continue

              try:
                  with open(json_path, 'r', encoding='utf-8') as f:
                      data = json.load(f)

                  meta = data.get('meta', {})
                  pages = data.get('pages', [])
                  thumbnail = pages[0]['image'] if pages else 'pages/page-0.webp'

                  manual_info = {
                      'name': folder.name,
                      'source': meta.get('source', folder.name),
                      'pages': len(pages),
                      'blocks': sum(len(p.get('blocks', [])) for p in pages),
                      'thumbnail': f'{folder.name}/{thumbnail}',
                      'source_url': meta.get('source_url', ''),
                  }

                  if 'tags' in meta:
                      manual_info['tags'] = meta['tags']

                  if not tag_definitions and 'tag_definitions' in meta:
                      tag_definitions = meta['tag_definitions']

                  manuals.append(manual_info)
              except Exception as e:
                  print(f'Warning: Could not read {json_path}: {e}')

          meta_data = {
              'manuals': manuals,
              'tags': tag_definitions,
              'stats': {
                  'total_manuals': len(manuals),
                  'total_pages': sum(m['pages'] for m in manuals),
                  'total_blocks': sum(m['blocks'] for m in manuals)
              }
          }

          meta_path = web_root / 'meta.json'
          with open(meta_path, 'w', encoding='utf-8') as f:
              json.dump(meta_data, f, ensure_ascii=False, indent=2)

          print(f'✅ Generated web/meta.json with {len(manuals)} manuals, {len(tag_definitions)} tag types')
          "

      - name: Setup deployment directory
        run: |
          mkdir -p _site
          cp -r web/* _site/
          cp -r manuals _site/

      - name: Setup Pages
        uses: actions/configure-pages@v5

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: '_site'

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

      - name: Purge Cloudflare Cache
        if: success()
        run: |
          # Always purge core site files that affect functionality
          URLS='"https://toku.solutions/index.html","https://toku.solutions/app.js","https://toku.solutions/styles.css","https://toku.solutions/meta.json"'

          # Add any changed files in web/ or manuals/
          CHANGED_FILES=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }} | grep -E '^(web|manuals)/' || echo "")

          while IFS= read -r file; do
            if [ ! -z "$file" ]; then
              # Remove web/ prefix for web files, keep manuals/ prefix for manual files
              if [[ "$file" == web/* ]]; then
                URL_PATH="${file#web/}"
              else
                URL_PATH="$file"
              fi
              URLS="$URLS,\"https://toku.solutions/$URL_PATH\""
            fi
          done <<< "$CHANGED_FILES"

          # Purge cache
          echo "Purging Cloudflare cache for core files and changes..."
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "https://api.cloudflare.com/client/v4/zones/${{ secrets.CLOUDFLARE_ZONE_ID }}/purge_cache" \
            -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
            -H "Content-Type: application/json" \
            --data "{\"files\":[$URLS]}")

          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | sed '$d')

          echo "Response: $BODY"

          if [ "$HTTP_CODE" -eq 200 ] && echo "$BODY" | grep -q '"success":true'; then
            echo "✅ Cloudflare cache purged successfully"
          else
            echo "⚠️  Cloudflare purge response: HTTP $HTTP_CODE"
            echo "This is non-fatal - deployment continues"
          fi
